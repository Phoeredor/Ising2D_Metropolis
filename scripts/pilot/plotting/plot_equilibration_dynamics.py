#!/usr/bin/env python3
"""
SCRIPT: plot_equilibration_dynamics.py
PURPOSE: Visualization of Monte Carlo equilibration and Critical Slowing Down.
         Generates publication-quality figures (PDF) for the project report.

INPUT:   Binary data from 'results/pilot/MC_convergence/' generated by
         'run_equilibration_diagnostics.sh'.
OUTPUT:  PDF plots in 'results/pilot/plots/'.
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
from pathlib import Path

# =============================================================================
# CONFIGURATION & CONSTANTS
# =============================================================================

# Project paths
BASE_DIR = Path(__file__).resolve().parents[3]
DATA_DIR = BASE_DIR / "results" / "pilot" / "MC_convergence"
PLOT_DIR = BASE_DIR / "results" / "pilot" / "plots"

# Create output directory if missing
PLOT_DIR.mkdir(parents=True, exist_ok=True)

# Binary File Structure (Must match C struct alignment)
HEADER_SIZE = 48
RECORD_DTYPE = np.dtype([
    ("sweep", "<i8"), 
    ("e", "<f8"), 
    ("m", "<f8"),
    ("e2", "<f8"), 
    ("m2", "<f8"), 
    ("m4", "<f8"),
])

# Logarithmic Binning Parameter
LOG_BASE = 2

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

def read_data(filename, flip_sign=False):
    """
    Reads simulation data from a binary file.
    """
    filepath = DATA_DIR / filename
    if not filepath.exists():
        # Try finding a matching pattern if exact name differs slightly
        candidates = list(DATA_DIR.glob(filename.replace(".bin", "*.bin")))
        if candidates:
            filepath = candidates[0]
        else:
            print(f"[WARN] File not found: {filename}")
            return None, None, None
    
    with open(filepath, "rb") as f:
        f.read(HEADER_SIZE) # Skip header
        data = np.fromfile(f, dtype=RECORD_DTYPE)
        
    t = data["sweep"]
    m = data["m"]
    e = data["e"]
    
    if flip_sign:
        m = -m
        
    return t, m, e

def log_binning(times, values, base=1.2):
    """
    Performs logarithmic binning on time-series data.
    """
    binned_t, binned_v = [], []
    curr_t, max_t = 1, times[-1]
    
    while curr_t < max_t:
        next_t = int(curr_t * base) + 1
        if next_t > max_t: next_t = max_t
        
        idx_start = max(0, curr_t - 1)
        idx_end = min(len(values), next_t - 1)
        
        if idx_end > idx_start:
            chunk = values[idx_start:idx_end]
            t_rep = np.sqrt(curr_t * next_t) # Geometric mean
            binned_t.append(t_rep)
            binned_v.append(np.mean(chunk))
            
        curr_t = next_t
        if curr_t >= max_t: break
            
    return np.array(binned_t), np.array(binned_v)

# =============================================================================
# PLOTTING ROUTINE
# =============================================================================

def main():
    # Set publication-quality style
    sns.set_theme(style="ticks", context="paper", font_scale=1.5)
    
    print(f"--- Generating Plots in: {PLOT_DIR} ---")

    # -------------------------------------------------------------------------
    # PLOT 1: CONVERGENCE TO EQUILIBRIUM (Ergodicity Check)
    # -------------------------------------------------------------------------
    print("-> Plot 1: Convergence to Equilibrium...")
    
    # SMART DETECTION: Find the Random Start file (Unique to High-T runs)
    rng_candidates = list(DATA_DIR.glob("rng_obs_L*.bin"))
    
    if not rng_candidates:
        print("[ERR] No 'rng_obs' files found in MC_convergence.")
        return

    # Pick the first one found
    f_rng_path = rng_candidates[0]
    f_rng = f_rng_path.name
    
    # Deduce partners (up and down) by replacing the prefix
    f_up   = f_rng.replace("rng_", "up_")
    f_down = f_rng.replace("rng_", "down_")
    
    print(f"   Using High-T set based on: {f_rng}")

    files_eq = [
        (f_up,   False, r"$m^{(+)}$", "up"),
        (f_rng,  False, r"$m^{(0)}$", "rng"),
        (f_down, True,  r"$m^{(-)}$", "down"),
    ]
    
    # Color Palette Setup
    vir_colors = plt.cm.viridis(np.linspace(0, 0.95, 5))
    c_m_up   = vir_colors[3] 
    c_m_rng  = vir_colors[2] 
    c_m_down = vir_colors[0] 
    
    inf_colors = plt.cm.inferno(np.linspace(0.4, 0.8, 3))
    c_e_up  = inf_colors[1]
    c_e_rng = inf_colors[0]

    fig, ax = plt.subplots(figsize=(8, 6), constrained_layout=True)
    
    # -- Plot Magnetization --
    for fname, flip, label, key in files_eq:
        t, m, e = read_data(fname, flip)
        if t is None: continue
        
        bt, bm = log_binning(t, m, base=LOG_BASE)
        
        if key == "up": c = c_m_up
        elif key == "rng": c = c_m_rng
        else: c = c_m_down
        
        ax.plot(bt, bm, 'o-', color=c, label=label, markersize=3, lw=1.5)

    # -- Plot Energy --
    for fname, flip, label, key in files_eq:
        if key == "down": continue 
        
        t, m, e = read_data(fname, flip)
        if t is None: continue
        
        bt, be = log_binning(t, e, base=LOG_BASE)
        
        e_label = r"$e^{(\pm)}$" if key == "up" else r"$e^{(0)}$"
        c = c_e_up if key == "up" else c_e_rng
            
        ax.plot(bt, be, 's--', color=c, label=e_label, markersize=3, lw=1.5, alpha=0.8)

    # -- Styling Plot 1 --
    ax.set_xscale("log")
    ax.set_xlim(1, None) 
    ax.set_ylim(-1.85, 1.05)
    
    ax.axhline(0, color='black', linestyle=':', lw=1)
    
    ax.set_xlabel(r"$t$", fontweight='bold', fontsize=18)
    ax.set_ylabel("") 
    
    ax.set_title("Convergence to Equilibrium", fontsize=20, pad=12)
    ax.legend(frameon=False, loc='upper left', fontsize=14, ncol=2) 
    ax.grid(True, which="major", ls="--", alpha=0.3)
    
    for spine in ax.spines.values():
        spine.set_linewidth(1.2)
        
    save_path1 = PLOT_DIR / "fig_equilibration.pdf"
    plt.savefig(save_path1)
    print(f" [OK] Saved: {save_path1}")


    # -------------------------------------------------------------------------
    # PLOT 2: MARKOV CHAIN RELAXATION (Critical Slowing Down)
    # -------------------------------------------------------------------------
    print("-> Plot 2: Critical Slowing Down...")
    
    # Identify all UP files
    all_up_files = list(DATA_DIR.glob("up_obs_L*.bin"))
    
    if not all_up_files:
        print("[ERR] No 'up_obs' files found.")
        return

    # Separate Critical from Off-Critical
    crit_file = None
    off_crit_files = []
    
    for f in all_up_files:
        if "CRIT" in f.name:
            crit_file = f
        else:
            off_crit_files.append(f)
            
    # Helper to extract beta for sorting
    def extract_beta(p):
        try:
            # Pattern: ...beta0.436... -> 0.436
            part = p.name.split("beta")[1]
            num_str = ""
            for char in part:
                if char.isdigit() or char == '.': num_str += char
                else: break
            return float(num_str)
        except:
            return 0.0
            
    # Sort off-critical by Beta value (Low Beta = Fast -> High Beta = Slow)
    off_crit_files.sort(key=extract_beta)
    
    files_to_plot = []
    
    # Add Off-Critical (Low Beta / High T)
    for i, f in enumerate(off_crit_files):
        beta_val = extract_beta(f)
        if i == 0: 
            label = r"$\beta \approx %.3f$ (Fast)" % beta_val
        else:      
            label = r"$\beta \approx %.3f$" % beta_val
